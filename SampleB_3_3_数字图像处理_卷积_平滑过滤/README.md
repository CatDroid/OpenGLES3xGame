# 卷积

卷积内核 是一个 nxn矩阵，n一般是奇数 ，所以宽是 （n+1） / 2 



![1541514333922](1541514333922.png)



平滑过滤(模糊)

| 1    | 1    | 1    |
| ---- | ---- | ---- |
| 1    | 1    | 1    |
| 1    | 1    | 1    |

shader中获取  左上角 一个像素的颜色

```
vec2 offset0=vec2(-1.0,-1.0); // 当前位置的偏移  左上角 
cTemp0=texture(sTexture, vTextureCoord.st + offset0.xy/512.0); // 归一化当前ST坐标 + 偏移归一化
```



### 常见边缘检测算子

Roberts 、Sobel 、Prewitt、Laplacian、Log/Marr、Canny、Kirsch、Nevitia

 #### 一阶微分算子：Roberts 、Sobel 、Prewitt



![1541600385231](1541600385231.png)

#### 各向同性Sobel算子 

![1541601029447](1541601029447.png)

模板的权值是离中心位置越远则权值（看绝对值）影响越小，如上图，把模板看成是9个小正方形，小正方形边长为1，则虚线三角形的斜边长为，下直角边长为1，则如果（0,0）位置权值绝对值大小为1，则按照距离关系，位置（1,0）处的权值绝对值大小应该为才是准确的。



#### 计算边缘幅值与方向？

比如sobel算子

![1541600620205](1541600620205.png)



求幅值时是有多种选择的，一般根据具体应用选择用水平还是竖直或是两个方向同时检测。 

#### **二阶微分算子：Laplacian、Log/Marr** 

拉普拉斯算子来自拉普拉斯变换，而Log算子又称Marr算子 

![1541601489609](1541601489609.png)

![1541601555814](1541601555814.png)



####   **非微分边缘检测算子：Canny** 





## 显示两张图片

如果要画两幅图片，显示在屏幕，思路:

1. 确定两个图片的矩形大小(假定一样大)
2. 假设 投影近平面距离是2 nearZ=2，近平面尺寸按物理屏幕计算为 -ratio ratio, 1,1 （假设ratio>1 也就是宽比高要大）
3. 可以按照下图，按比例算出，摄像头位置，和两个矩形位移距离

![1541518367527](1541518367527.png)



## shader中初始化Mat矩阵

1. mat2x3 代表是2列3行

2. mat2x3 a1 = mat2x3 (1.0, 2.0, 3.0,   4.0 ,5.0, 6.0) 代表

   | 1    | 4    |
   | ---- | ---- |
   | 2    | 5    |
   | 3    | 6    |

   

## shader中颜色置反

```
fFragColor =  vec4(1.0) -  fFragColor;  // 注意 颜色的范围是0~1 所以置反也是 (1-x)
```