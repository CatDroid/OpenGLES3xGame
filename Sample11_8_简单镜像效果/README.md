#### 关闭深度缓冲与深度缓冲可读
* glDepthMask(GL_FALSE); 可将深度缓冲区设置为只读形式 
* 虽然关闭了深度写入，但是没有关闭了深度缓冲，此时深度缓冲还是可读的，可以进行深度测试
* glDepthMask(GL_TRUE) ; 可将深度缓冲区设置为可读可写形式
* glDisable(GL_DEPTH_TEST); 关闭深度检测 
* 深度测试、深度写入
  * 关闭了深度检测，深度写入也是不能的；但相反打开深度检测，是可以单独关闭深度写入的
  * 如果关闭了深度写入(glDepthMask(false))，那么glClear(GL_DEPTH_BUFFER_BIT)会没有作用，也就是深度buffer还是会有上一次的深度值，但是clear Color有作用，结果就是该深度位置是黑色，下次画同一个物体时候，就会出现深度冲突，出现沙粒效果，如图：
![glDepthMask](glDepthMask_false_AndThen_glClear.png)

* 深度缓冲 z-buffer，默认情况下深度测试是关闭的
* 深度缓冲有系统窗口创建并将其深度值存储为16、24或32位的浮点数。一般使用的是24位深度缓冲区
* 开启深度测试后，片段的深度信息z值将存储在深度缓冲区中，测试时，将当前的片段的深度值与缓冲区的 z 值进行比较，大于缓冲区的 z 值时，将丢弃该片段；否则保留该片段并更新深度缓冲区的深度值。
* 启用深度测试时，还应该使用glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT) 清除深度缓冲区，否则将保留上一次进行深度测试时写入的深度信值
* 深度测试函数(depth function)，默认的函数是glDepthFunc(GL_LESS)， 在片段深度值小于深度缓冲区使测试通过
* glDepthFunc(GL_ALWAYS)，相当于默认情况下的没有开启深度测试的效果相同
* 渲染顺序,深度测试和深度写入流程
![render_sequence](渲染顺序.jpg)
![depth_sequence](深度测试流程.jpg)
![blend_sequence](混合blend流程.jpg)
![close_depth_test](close_depth_test.png)


#### 内置变量
* gl_Position 顶点着色器写入顶点位置坐标到渲染管线，类型是vec4 
* gl_PointSize 顶点着色器把一个点的大小写入渲染管线，单位像素，仅在点绘制有意义
* gl_FragCoord vec4 片元着色器 可以获取当前绘制片元在视口中的位置，其中z表示深度
* gl_FrontFacing 布尔值，片元着色器，在光栅化阶段当前片元是否在对应图元的正面，用于双面关照
* gl_PointCoord vec2 点精灵，当前图元中片元的位置，从0~1


#### 深度可视化 深度冲突
* <https://blog.csdn.net/u011371324/article/details/77414190>
* 远处深度值大，对应灰度图的白色，而且远处的颜色精度低，所以看起来都是白色的
* 深度的非线性特点，近处时，稍微移动一点，颜色就会明显由暗变亮或由亮变暗
```
void main()
{
    color = vec4(vec3(gl_FragCoord.z), 1.0f); 
    // 使用内建变量gl_FragCoord知道当前片元的标准设备空间系中的坐标
} 
```
* 当距离越远时越容易出现，因为距离较远时精度较低，这时候无法区分开哪些三角形在前，哪些在后，就会导致两个物体的面相互交替出现
* 远处的物体不用很好分辨出远近，而近处的物体则需要很好分辨远近，即远处和近处得深度值应该有不同的精度，所以采用了 1/z 来计算深度信息，则距离近平面较近的拥有很高的精度，距离越远精度值越低
* 解决深度冲突：
  * 1.增加远处物体距离 
  * 2.深度缓冲精度24bit到32bit 
  * 3.近平面选远点，但又要保证近处的物体不会被裁剪掉


#### 渲染常用顺序：
* 先渲染所有不透明物体，开启深度测试和深度写入
* 半透明物体按离摄像机距离远近排序，从后往前渲染，开启深度测试，关闭深度写入(由于需要手动排序半透明的物体，写入深度已没有意义，还有排序不完美，见下)
* 如果能完美地手工排序不透明fragment(不是图元,而是光栅化后的片元)，写入深度也没有影响；但若(?半透明的?)物体在深度方向有重叠，有些fragment的顺序会有误，如果开启深度写入，会令到渲染错误很明显(?后画的本来是近处的半透明物体中比较深的部分会由于另外一个比较深的半透明物体挡住而深度测试丢弃，没有混合?)，而关掉的话影响较小一点(即使混合有可能是有问题的)。
* 交叉物体的渲染 
  * <https://www.zhihu.com/question/60898307> 
  * 对于半透明的渲染，是可以同时开启深度测试和深度写入的。方法是使用2个Pass。一个先只负责保证像素级片元深度正确，一个负责渲染


#### 物理知识
* 势能分为重力势能、磁场势能、弹性势能、分子势能、电势能、引力势能 等
* 重力势能 (gravitational potential energy）是物体因为重力作用而拥有的能量，公式为Ep=mgh(m 质量，g应取9.8N/kg，h物体据水平面的高度，把地面选作零势能位置）
* 动能公式 Ek= 0.5*mv² 
* 在不考虑空气阻力的情况下，根据能量守恒，球往上抛到达最高点时，动能转换为势能，0.5*mv² = mgh，v是初始速度 h是高度，0.5v²=gh 
* 瞬间速度和加速度  v = v0 + at  v0=0  a=g=9.8m/s²
* 位移和加速度s=∫[t,0] (v0 + gt) dt, s = v0*t + 0.5gt² 

#### Demo理论根据
* 不考虑空气阻力，反弹后上抛初始速度等于下降触碰前速度
* 以向上为正方向(y轴的正方向为参考正方向)，某个时间点的位移为s=s0+v0*t+0.5gt²
* 第一次从高处落下时，s0=h，v0=0，g=-9.8
* 以后每次触碰反弹，s0=0，v0=计算损耗反弹后初始速度，g=-9.8
* 考虑第一次下落时候初始速度是0，所以反弹后初始速度按照时间来计算 v反 = (v原 - gt²) * -1 * 0.8f
* -1代表反弹，方向转换；0.8f是恢复系数

#### 镜像
* 绘制镜像时候，要把卷绕方式从逆时针改成顺时针
    * 打开背面剪裁
    ```
    GLES30.glEnable(GLES30.GL_CULL_FACE); 
    ```
    * 顺时针卷绕 
    ```
    GLES30.glFrontFace(GLES30.GL_CW);  
    ```
    * 逆时针卷绕
    ```
    GLES30.glFrontFace(GLES30.GL_CCW);   
    ```
* 上下或者左右镜像，可以使用scale坐标转换矩阵
    * Matrix.scaleM(currMatrix,0, 1, -1, 1); // 关于xoz平面的镜像

#### example
![example](examle_noAlpha_floor.png)
![example](examle_Alpha_floor.png)